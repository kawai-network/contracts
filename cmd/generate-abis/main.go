package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const outputTemplate = `package contracts

// Code generated by cmd/generate-abis; DO NOT EDIT.

var ProjectABIs = map[string]string{
{{- range $name, $abi := . }}
	"{{ $name }}": ` + "`{{ $abi }}`" + `,
{{- end }}
}
`

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: generate-abis <output-file> <input-dir>")
		os.Exit(1)
	}

	outputFile := os.Args[1]
	inputDir := os.Args[2]

	fmt.Printf("Input Dir: %s\n", inputDir)
	fmt.Printf("Output File: %s\n", outputFile)

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		panic(fmt.Errorf("failed to create output dir: %v", err))
	}

	abis := make(map[string]string)

	err := filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".abi") {
			content, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			// Use the filename without extension as the key (e.g., "KawaiToken")
			name := strings.TrimSuffix(filepath.Base(path), ".abi")
			fmt.Printf("Found ABI: %s\n", name)
			abis[name] = string(content)
		}
		return nil
	})

	if err != nil {
		panic(fmt.Errorf("walk failed: %v", err))
	}

	f, err := os.Create(outputFile)
	if err != nil {
		panic(fmt.Errorf("create file failed: %v", err))
	}
	defer f.Close()

	tmpl := template.Must(template.New("abis").Parse(outputTemplate))
	if err := tmpl.Execute(f, abis); err != nil {
		panic(err)
	}

	fmt.Printf("Generated %s with %d ABIs\n", outputFile, len(abis))
}
